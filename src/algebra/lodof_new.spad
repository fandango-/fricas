)abbrev package LODOFN LinearOrdinaryDifferentialOperatorFactorizerNew
++ Description:
++ \spadtype{LinearOrdinaryDifferentialOperatorFactorizerNew} provides a
++ factorizer for linear ordinary differential operators whose coefficients
++ are rational functions.
++ Keywords: differential equation, ODE, LODO, factoring
LinearOrdinaryDifferentialOperatorFactorizerNew(F, UP, var, cen) : Exports == Impl where
  F : Join(Field, CharacteristicZero,
           RetractableTo Integer, RetractableTo Fraction Integer)
  UP : UnivariatePolynomialCategory F
  var : Symbol
  cen : F

  RF ==> Fraction UP
  L  ==> LinearOrdinaryDifferentialOperator1 RF
  L2 ==> LinearOrdinaryDifferentialOperator2(UP, RF)
  L3 ==> LinearOrdinaryDifferentialOperator3(F, UP, RF)
  US ==> UnivariateLaurentSeries(F, var, cen)
  LL ==> LinearOrdinaryDifferentialOperator3(F, UP, US)
  PO ==> Record(x : Integer, y : Integer)
  FZ ==> Fraction Integer
  FA ==> Record(factor : UP, exponent : Integer)
  F2 ==> Record(Qt : LL, Rt : LL)
  NL ==> Record(factors : F2, r_l : LL)

  Exports ==> with
    testnp : L3 -> List(Record(point : PO, slope : FZ, npoly : UP))
    ++ test function.
    testfn : (L3, UP -> Factored(UP), String) -> List LL
    ++ test function.
    testf2 : (L3, UP, FZ) -> F2
    ++ test function.
    testos : (Integer, FZ, FZ, UP) -> LL
    ++ test function.

  Impl ==> add
    import from IntegerRetractions(F)

    convertL3toLL : L3 -> LL
    newtonpolygonPoints : LL -> List PO
    newtonpolygon : LL -> List(Record(point : PO, slope : FZ, npoly : UP))
    factor_newton : (LL, UP -> Factored(UP), String) -> List LL
    factor_newton2 : (LL, UP, FZ) -> F2
    op_with_slope : (Integer, FZ, FZ, UP) -> LL
    lift_newton : (US, FZ, LL, UP, UP, FZ, F2, LL, Integer) -> NL
    coefs_operator : (LL, FZ, Integer) -> UP
    coefs_operator1 : (UP, FZ, Integer) -> LL
    coeffx : (LL, FZ) -> UP
    plug_delta : UP -> LL
    nm_mult : (LL, LL, Integer, Integer) -> LL
    nm_block : (LL, FZ, FZ, FZ, FZ -> Integer) -> LL

    convertL3toLL(f) ==
        tools := UTSodetools(F, UP, L2, UnivariateTaylorSeries(F, var, cen))
        apf : LinearOrdinaryDifferentialOperator3(F, UP, US) := 0
        ftmp := f
        while ftmp ~= 0 repeat
            lc := leadingCoefficient(ftmp)
            den := UP2UTS(denom lc) :: US
            apf := (apf +
                    monomial((UP2UTS(numer lc)$tools *
                    recip(den) :: US), degree(ftmp)))
            ftmp := reductum ftmp
        apf

-- newtonpolygonPoints takes a LinearOrdinaryDifferentialOperator3 having
-- Laurent series coefficients as input and returns the coordinates of the
-- extreme points of the Newton polygon.
    newtonpolygonPoints(f) ==
        ftmp := f
        points : List PO := []
        yzero := order(leadingCoefficient(ftmp))
        while ftmp ~= 0 repeat
            xv := degree(ftmp)
            yv := order(leadingCoefficient(ftmp))
            if xv ~= 0 then
                points := cons([xv, yv], points)
            yzero := min(yzero, yv)
            ftmp := reductum ftmp
        points := cons([0, yzero], points)
        npg : List PO := [points.2, points.1]
        points3 := rest(rest(points))
        for i in points3 repeat
            ccw : Boolean := true
            while #npg > 1 and ccw repeat
                p1 := npg.2
                p2 := npg.1
                sb1 := (p2.x - p1.x) * (i.y - p1.y)
                sb2 := (p2.y - p1.y) * (i.x - p1.x)
                ccw := (sb1 - sb2) <= 0
                if ccw then
                    npg := rest(npg)
            npg := cons(i, npg)
        reverse!(npg)

--    newtonpolygonPoints(f) ==
--        n := degree(f)
--        vals := [order(coefficient(f, i), order(leadingCoefficient(f)))
--                 for i in 0..n]
--        powd : Integer := 0
--        val_powd := vals.1
--        vals1 := vals.1
--        for i in vals | i ~= vals1 repeat
--            val_powd := min(val_powd, i)
--        npg : List PO := [[powd, val_powd]]
--        while powd < n repeat
--            m := (vals(powd+2) - val_powd) :: Fraction Integer
--            for j in 2..(n - powd) repeat
--                m := min(m, (vals(powd+j+1) - val_powd) / j)
--            i : Integer := n
--            while (vals(i+1)-val_powd) :: Fraction Integer ~= (i-powd)*m repeat
--                i := i - 1
--            powd := i
--            val_powd := vals(i+1)
--            npg := append(npg, [[i, vals(i+1)]])
--        npg

-- newtonpolygon takes a LinearOrdinaryDifferentialOperator3 having Laurent
-- series coefficients as input and returns the coordinates of the extreme
-- points of the Newton polygon, the slope of a point to the next point and the
-- Newton polynomial of this slope.
    newtonpolygon(f) ==
        npg : List PO := newtonpolygonPoints(f)
        res : List(Record(point : PO, slope : FZ, npoly : UP)) := []
        restl := rest(npg)
        for i in npg for nxt in restl repeat
            -- now we compute the Newton polynomial of slope number i
            slop : FZ := (nxt.y - i.y) / (nxt.x - i.x)
            npol : UP := 0
            for j in 0..qcoerce((nxt.x - i.x) quo denom(slop)) repeat
                ind : NonNegativeInteger := qcoerce(denom(slop) * j + i.x)
                opc := coefficient(f, ind)
                lsc := coefficient(opc, j * numer(slop) + i.y)
                npol := npol + monomial(lsc, j)
            res := append(res, [[i, slop, npol]])
        res

    testnp(f) ==
        newtonpolygon(convertL3toLL(f))

    factor_newton(f, factorizer, option) ==
        if degree(f) <= 1 then
            return [f]
        np := newtonpolygon(f)
        res : List LL := []
        unsafe : Set FA
        for k in np repeat
            npol := k.npoly
            v := factors(factorizer(npol))
            if k.slope ~= 0 then
                v := [[il.factor ^ qcoerce(il.exponent), 0] for il in v]
            else
                -- regular singular case, we compute the unsafe factors
                unsafe := set []
                -- n_unsafe is the number of factors with an exponent that is
                -- the exponent of this factor i minus a positive integer.
                n_unsafe : Table (FA, Integer) := table()
                semi : Table(FA, UP) := table()
                for i in v repeat
                    n_unsafe(i) := 0
                    semi(i) := i.factor ^ qcoerce(i.exponent)
                for i in v for ii in 1..(#v)-1 repeat
                    restl := rest(v, ii)
                    vif : UP := i.factor
                    dvif := degree(vif)
                    for j in restl repeat
                        vjf : UP := j.factor
                        if dvif = degree(vjf) then
                            d := qcoerce(dvif - 1)
                            e : F := coefficient(vif, d) - coefficient(vjf, d)
                            e := e / ((dvif :: Integer) :: F)
                            if integer?(e) and e ~= 0 then
                                ie := integer(e)
                                id := d :: Integer
                                quot := (ie quo (id + 1)) :: UP
                                newx : UP := monomial(1,1) + quot
                                sbt := eval(vjf, monomial(1,1), newx)
                                (vif - sbt) ~= 0 => "iterate"
                                if ie > 0 then
                                    unsafe := union(unsafe, i)
                                    n_unsafe(j) := (n_unsafe(j)+i.exponent)
                                    semi(j) := (semi(j) * vif ^
                                                qcoerce(i.exponent))
                                else
                                    unsafe := union(unsafe, j)
                                    n_unsafe(i) := (n_unsafe(i)+j.exponent)
                                    semi(i) := (semi(i) * vjf ^
                                                qcoerce(j.exponent))
                v := members(difference(set(v), unsafe))
                if option = "semireg" then
                    v := [[semi(i), 1] for i in v]
            -- now v contains the safe right factors of slope number k
            slo := k.slope
            if degree(v(1).factor) * denom(slo) = degree(f) then
                -- f allows no coprime index 1 factorization
                return [f]
            for i in v repeat
                jl : F2 := factor_newton2(f, i.factor, slo)
                if option = "alg factor" then
                    return [jl.Rt]
                else if option = "split over k((x))" then
                    return append(factor_newton(jl.Qt, factorizer, option),
                                  [jl.Rt])
                res := append(res, [jl.Rt])
        res

    testfn(f, factorizer, option) ==
        factor_newton(convertL3toLL(f), factorizer, option)

-- this is a work in progress.
    factor_newton2(f, r, slop) ==
        np := newtonpolygon(f)
        l : Record(point : PO, slope : FZ, npoly : UP)
        for i in np repeat
            if i.slope = slop then
                l := i
        ycd : Integer := l.point.y
        xcd : Integer := l.point.x
        npol := l.npoly
        shift := min(0, ycd :: FZ + (degree(f) - xcd) * slop)
        -- we will compute the newton polynomial of the left factor
        npo : UP := monomial(1, qcoerce(xcd))
        mlr : UP := eval((npol quo r),monomial(1,1),monomial(1,qcoerce(denom(slop))))
        npo := npo * mlr
        npo2 : UP := eval(r, monomial(1, 1), monomial(1, qcoerce(denom(slop))))
        ord1 := degree(f) - degree(r) * denom(slop)
        ord2 := degree(r) * denom(slop)
        res1 := op_with_slope(ord1, slop, shift, npo)
        res2 := op_with_slope(ord2, slop, 0, npo2)
        rem_lift : LL := 0
        for i in 0..ord1-1 repeat
            r1c := coefficient(res1, i)
            lnr := lift_newton(r1c, slop, f, npo, npo2, shift, [res1, res2],
                               rem_lift, degree(r1c)+1)
            res1 := lnr.factors.Qt
            res2 := lnr.factors.Rt
            rem_lift := lnr.r_l
        for i in 0..ord2-1 repeat
            r2c := coefficient(res2, i)
            lnr := lift_newton(r2c, slop, f, npo, npo2, shift, [res1, res2],
                               rem_lift, degree(r2c)+1)
            res1 := lnr.factors.Qt
            res2 := lnr.factors.Rt
            rem_lift := lnr.r_l
        [res1, res2]

    testf2(f, r, slop) ==
        factor_newton2(convertL3toLL(f), r, slop)

    op_with_slope(order, slop, shift, npo) ==
        result : LL := monomial(1, qcoerce(order))
        for i in 0..order-1 repeat
            exp := ceiling((i - order) * slop + shift)
            result := result + monomial(monomial(coefficient(npo, i), exp), i)
        result

    testos(order, slop, shift, npo) ==
        op_with_slope(order, slop, shift, npo)

    lift_newton(llaur, slop, ff, l_low, r_low, shift, v, rem_lift, acc) ==
        n_lifts := (acc - degree(llaur)) :: FZ
        if n_lifts <= 0 then
            return [v, rem_lift]
        left := v.Qt
        right := v.Rt
        n_known := (degree(coefficient(right, 0)) :: FZ +
                    (degree(right) * slop))
        f : LL := nm_block(ff, n_known+shift, n_known+n_lifts+shift, slop, ceiling)
        l := left
        if n_known + shift <= 0 then
            l := l - monomial(1, degree(l))
        r : LL
        if n_known = 0 then
            r := 0
        else
            r := right
        a1 := ceiling(n_known + shift - slop * (degree(ff) :: Integer))
        a2 := ceiling(n_known + shift + n_lifts) - 1
        arg1 := a2 + 1 - retract(n_lifts)@Integer
        lr : LL := rem_lift - f + nm_mult(l, r, arg1, a2)
        n_k := retract(n_known)@Integer
        n_l := retract(n_lifts)@Integer
        if slop = 0 then
            -- regular singular case
            for i in n_k..n_k+n_l-1 repeat
                r_extra : LL
                l_extra : LL
                if i = 0 then
                    r_extra := plug_delta(r_low)
                    l_extra := (plug_delta(l_low) * monomial(1,
                                                    retract(shift)@Integer)$US)
                else
                    ltmp := l_low
                    sl_low : UP := 0
                    while ltmp ~= 0 repeat
                        lc := leadingCoefficient(ltmp)
                        dg := degree(ltmp)
                        sl_low := sl_low + (monomial(1, 1) + i :: UP) ^ dg
                        ltmp := reductum ltmp
                    s := extendedEuclidean(r_low, sl_low)
                    if s.generator ~= 1 then
                        error "unsafe factor"
                    c1 := s.coef1
                    c2 := s.coef2
                    clr := coeffx(lr, i :: FZ + shift)
                    r_extra1 := -((c2 * clr) rem r_low)
                    r_extra := plug_delta(r_extra1)
                    l_extra1 := (clr + r_extra1 * l_low) quo r_low
                    l_extra := plug_delta(l_extra1)
                    l_extra := -(monomial(1, i + retract(shift)@Integer)$US *
                                 l_extra)
                    r_extra := monomial(1, i)$US * r_extra
                l := l + l_extra
                lr := lr + nm_mult(l, r_extra, a1, a2) + nm_mult(l_extra, r, a1, a2)
                r := r + r_extra
        else
            s := extendedEuclidean(r_low, l_low, 1) :: Record(coef1 : UP, coef2 : UP)
            c1 := s.coef1
            c2 := s.coef2
            le : Integer := denom(slop) * retract(shift)@Integer
            le := le - numer(slop) * degree(left)
            re : Integer := -(numer(slop) * degree(right))
            fe : Integer := denom(slop) * retract(shift)@Integer
            fe := fe - numer(slop) * degree(ff)
            for i in n_k*denom(slop)..(n_k+n_l)*denom(slop)-1 repeat
                r_extra : LL
                l_extra : LL
                if i = 0 then
                    r_extra := coefs_operator1(r_low, slop, re)
                    l_extra := coefs_operator1(l_low, slop, le)
                else
                    r_extra1 := (c2 * coefs_operator(lr, slop, i+fe)) rem r_low
                    l_extra1 := coefs_operator(lr, slop, i+fe) - r_extra1*l_low
                    l_extra1 := -(l_extra1 quo r_low)
                    l_extra := coefs_operator1(l_extra1, slop, i + le)
                    r_extra := coefs_operator1(-(r_extra1), slop, i + re)
                l := l + l_extra
                lr := lr + nm_mult(l, r_extra, a1, a2) + nm_mult(l_extra, r, a1, a2)
                r := r + r_extra
        [[l, r], lr]

    coefs_operator(f, slop, i) ==
        start_D := (-i quo numer(slop)) rem denom(slop)
        start_x := start_D * slop + i /$FZ denom(slop)
        res : UP := 0
        for j in 0..floor(degree(f) /$FZ denom(slop)) repeat
            fc := coeffx(f, start_x + numer(slop) * j :: FZ)
            npc := coefficient(fc, qcoerce(start_D + j * denom(slop)))
            res := res + monomial(npc, qcoerce(start_D + j * denom(slop)))
        res

    coefs_operator1(np, slop, i) ==
        start_D := (-i quo numer(slop)) rem denom(slop)
        start_x := retract(start_D * slop + i /$FZ denom(slop))@Integer
        res : LL := 0
        for j in 0..ceiling(degree(np) /$FZ denom(slop)) repeat
            npc := coefficient(np, qcoerce(start_D + j * denom(slop)))
            sc := monomial(npc, start_x + numer(slop) * j)
            res := res + monomial(sc, qcoerce(start_D + j * denom(slop)))
        res

    coeffx(f, e) ==
        ftmp := f
        ex := retract(e)@Integer
        res : UP := 0
        while ftmp ~= 0 repeat
            lc := leadingCoefficient(ftmp)
            dg := degree(ftmp)
            while lc ~= 0 repeat
                slc := leadingCoefficient(lc)
                sdg := degree(lc)
                if sdg = ex then
                    res := res + monomial(slc, dg)
                lc := reductum lc
            ftmp := reductum ftmp
        res

    plug_delta(np) ==
        f : LL := 0
        nptmp := np
        while nptmp ~= 0 repeat
            lc := leadingCoefficient(nptmp)
            dg := degree(nptmp)
            f := f + monomial(lc :: US, dg)
            nptmp := reductum nptmp
        f

    nm_mult(l, r, low, high) ==
        ldl := degree(leadingCoefficient(l))
        dl := ldl
        ldr := degree(leadingCoefficient(r))
        dr := ldr
        cl : Table(Integer, LL) := table()
        cr : Table(Integer, LL) := table()
        ltmp := l
        while ltmp ~= 0 repeat
            lc := leadingCoefficient(ltmp)
            dg := degree(ltmp)
            while lc ~= 0 repeat
                slc := leadingCoefficient(lc)
                sdg := degree(lc)
                if key?(sdg, cl) then
                    cl.sdg := cl.sdg + monomial(slc :: US, dg)
                else
                    cl.sdg := monomial(slc :: US, dg)
                ldl := min(ldl, sdg)
                dl := max(dl, sdg)
                lc := reductum lc
            ltmp := reductum ltmp
        rtmp := r
        while rtmp ~= 0 repeat
            lc := leadingCoefficient(rtmp)
            dg := degree(rtmp)
            while lc ~= 0 repeat
                slc := leadingCoefficient(lc)
                sdg := degree(lc)
                if key?(sdg, cr) then
                    cr.sdg := cr.sdg + monomial(slc :: US, dg)
                else
                    cr.sdg := monomial(slc :: US, dg)
                ldr := min(ldr, sdg)
                dr := max(dr, sdg)
                lc := reductum lc
            rtmp := reductum rtmp
        res : LL := 0
        for j in max(ldr, low - dl)..min(high - ldl, dr) repeat
            res1 : LL := 0
            if key?(j, cr) then
                res1 := cr.j * monomial(1, j)$US
            res2 : LL := 0
            for i in max(ldl, low - j)..min(dl, high - j) repeat
                cli : LL := 0
                if key?(i, cl) then
                    cli := cl.i
                scli : LL := 0
                while cli ~= 0 repeat
                    lc := leadingCoefficient(cli)
                    dg := degree(cli)
                    ad := j :: LL
                    scli := scli + leadingCoefficient(cli) *
                                   (monomial(1, 1) + ad) ^ degree(cli)
                res2 := res2 + scli * monomial(1, i)$US
            res := res + res1 * res2
        res

    nm_block(f, n, m, slop, round_off) ==
        res : LL
        if (round_off(n) <= 0) and (0 < round_off(m)) then
            res := monomial(1, degree(f))
        else
            res := 0
        df := degree(f) :: Integer
        for i in df-1..0 by -1 repeat
            res := res + monomial(truncate(coefficient(f, qcoerce(i)),
                                           round_off(m + slop * (i - df)),
                                           round_off(n + slop * (i - df))),
                                           qcoerce(i))
        res

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- Compile order for the differential equation solver:
-- oderf.spad  odealg.spad  nlode.spad  nlinsol.spad  riccati.spad
-- kovacic.spad  lodof.spad  odeef.spad
